# Общая информатика
© Бибиков Сергей, к.т.н., доцент, кафедра суперкомпьютеров и общей информатики, Самарский университет

## Лекция 4

### Указатели в C++

__Что такое указатели?__

__Указатель__ – переменная, значением которой является адрес ячейки памяти. То есть указатель ссылается на блок данных из области памяти, причём на самое его начало. Указатель может ссылаться на переменную или функцию. Для этого нужно знать адрес переменной или функции. Так вот, чтобы узнать адрес конкретной переменной в С++ существует унарная операция взятия адреса ```&```. Такая операция извлекает адрес объявленных переменных, для того, чтобы его присвоить указателю.

__Зачем они нужны?__
Указатели используются для передачи данных по ссылке (передаем только адрес), а не копированием (передаем копию всех данных, а перед этим копируем).  В основном указатели используются для организации динамического распределения памяти, например при объявлении массива, не надо будет его ограничивать в размере. Ведь программист заранее не может знать, какого размера нужен массив тому или иному пользователю, в таком случае используется динамическое выделение памяти под массив. Любой указатель необходимо объявить перед использованием, как и любую переменную.

__Как их задать?__
```c++
//объявление указателя
/*тип данных*/  * /*имя указателя*/;
//Примеры:
int * int_pointer_name; // указатель на число типа int
double * double_pointer_name; // указатель на число типа double
```

__Как получить данные через указатель?__

Чтобы получить значение, записанное в некоторой области, на которое ссылается указатель нужно воспользоваться операцией разыменования указателя \*. Необходимо поставить звёздочку перед именем и получим доступ к значению указателя.

__Как получить адрес данных, чтобы записать в указатель?__

Чтобы получить адрес по которому переменная (например) ```a```, нужно перед ней записать символ ```&```. Это может выглядеть следующим образом:
```c++
int a = 10; \\ объявляем целочисленную переменную и инициализируем ее значением 10
int *ptr_a = &a; \\ объявляем указатель на целое число и инициализируем его адресом переменной a
```
__Пример:__

```c++
#include <iostream>
using namespace std;
 
int main()
{
    int var = 123; // инициализация переменной var числом 123
    int *ptrvar = &var; // указатель на переменную var (присвоили адрес переменной указателю)
    cout << "&var    = " << &var << endl;// адрес переменной var содержащийся в памяти, извлечённый операцией взятия адреса
    cout << "ptrvar  = " << ptrvar << endl;// адрес переменной var, является значением указателя ptrvar
    cout << "var     = " << var << endl; // значение в переменной var
    cout << "*ptrvar = " << *ptrvar << endl; // вывод значения содержащегося в переменной var через указатель, операцией разименования указателя
    return 0;
}
```
_Что программа выведет в консоль?_
```
&var    = 0x22ff08
ptrvar  = 0x22ff08
var     = 123
*ptrvar = 123
```
__Указатели на указатели__

Можно создавать указатели, которые будут указывать на другие указатели. То есть там будет храниться адрес, по которому в памяти хранится адрес, по которому хранится значение. Это делается с помощью двух символов ```**```:

```c++
int a = 10; \\ объявляем целочисленную переменную и инициализируем ее значением 10
int *ptr_a = &a; \\ объявляем указатель на целое число и инициализируем его адресом переменной a
int **ptr_ptr_a = &ptr_a; \\ объявляем указатель на указатель на целое число и инициализируем его адресом указателя ptr_a
```

Сами по себе указатели на указатели встречаются не часто в программировании, но для динамических массивов различной размерности применяются именно они. Об этом чуть позже.

__Пример:__

```c++
#include <iostream>
using namespace std;
 
int main()
{
    int var = 123; // инициализация переменной var числом 123
    int *ptrvar = &var; // указатель на переменную var
    int **ptr_ptrvar = &ptrvar; // указатель на указатель на переменную var
    int ***ptr_ptr_ptrvar = &ptr_ptrvar;
    cout << " var\t\t= " << var << endl;
    cout << " *ptrvar\t= " << *ptrvar << endl;
    cout << " **ptr_ptrvar   = " << **ptr_ptrvar << endl; // два раза разименовываем указатель, так как он второго порядка
    cout << " ***ptr_ptrvar  = " << ***ptr_ptr_ptrvar << endl; // указатель третьего порядка
    cout << "\n ***ptr_ptr_ptrvar -> **ptr_ptrvar -> *ptrvar ->      var -> "<< var << endl;
    cout << "\t  " << &ptr_ptr_ptrvar<< " -> " << "    " << &ptr_ptrvar << " ->" << &ptrvar << " -> " << &var << " -> " << var << endl;
    return 0;
}
```
_Что программа выведет в консоль?_

```
var            = 123
*ptrvar        = 123
**ptr_ptrvar   = 123
***ptr_ptrvar  = 123

***ptr_ptr_ptrvar -> **ptr_ptrvar -> *ptrvar ->      var -> 123
         0x22ff00 ->     0x22ff04 ->0x22ff08 -> 0x22ff0c -> 123
```
Помимо этого, можно делать указатели на функции. Но это слегка выходит за рамки курса. Просто следует помнить о такой возможности.

### Ссылки в C++

__Что такое ссылки?__

__Ссылки__ – особый тип данных, являющийся скрытой формой указателя, который при использовании автоматически разименовывается. Ссылка может быть объявлена как другим именем, так и как псевдоним переменной, на которую ссылается.

__Зачем они нужны?__

Ссылки, как правило, в большинстве случаев используют в функциях как ссылки-параметры или ссылки-аргументы.  Когда происходит передача по значению, те данные, которые необходимо передать, нужно сначала скопировать, а когда передаётся большой объём данных, то только на передачу затрачивается большое количество времени и ресурсов. В таком случае необходимо использовать передачу по ссылке, в этом случае данные копировать нет необходимости, так как к ним обеспечен прямой доступ, но __нарушают безопасность данных__, хранимых в ссылочных переменных, так как открывают прямой доступ к этим данным.

__Как их задать?__

```c++
// структура объявления ссылок
/*тип*/ &/*имя ссылки*/ = /*имя переменной*/;
```

При объявлении ссылки перед её именем ставится символ амперсанда ```&```, сама же ссылка должна быть проинициализирована именем переменной, на которую она ссылается. 
Грубо говоря, создается второе имя для переменной. И с этим вторым названием можно работать точно так же, как и с первым.

__Пример:__

```c++
#include <iostream>
using namespace std;
 
int main()
{
    int value = 15;
    int &reference = value; // объявление и инициализация ссылки значением переменной value
    cout << "value     = " << value     << endl;
    cout << "reference = " << reference << endl;
    reference+=15; // изменяем значение переменной value посредством изменения значения в ссылке
    cout << "value     = " << value     << endl; // смотрим, что получилось, как будет видно дальше значение поменялось как в ссылке,
    cout << "reference = " << reference << endl; //  так и в ссылочной переменной
    return 0;
}
```

__В чем разничца между указателями и ссылками?__

В чём же разница между указателями  и ссылками? Основное назначение указателя – это организация динамических объектов, то есть размер, которых может меняться (увеличиваться или уменьшаться). Тогда как ссылки предназначены для организации прямого доступа к тому, или иному объекту. Главное отличие состоит во внутреннем механизме работы. Указатели ссылаются на участок в памяти, используя его адрес. А ссылки ссылаются на объект, по его имени (тоже своего рода адрес). 

__Как защитить целостность данных при использовании ссылок и указателей для передачи в функцию аргументов?__

Если нет необходимости изменить передаваемое значение в ссылочной переменной, но нужно выиграть в скорости, используйте спецификатор ```const``` в объявлении параметров функций. Только так и можно защитить данные от случайного их изменения или полной потере.

```c++
int sum_by_reference(const int &reference) // функция принимающая аргумент по ссылке
// квалификатор const не даёт изменить передаваемый аргумент внутри функции
```


### Динамические массивы C++

__Динамическое выделение памяти__

Динамическое выделение памяти необходимо для эффективного использования памяти компьютера. Например, мы написали какую-то программу по обработке массив. При написании данной программы необходимо было объявить (статический) массив, то есть задать ему фиксированный размер. Тогда данная программа не будет универсальной, она может обрабатывать массив размером не более 100 элементов. А если понадобятся всего 20 элементов, но в памяти выделится место под 100 элементов, ведь объявление массива было статическим, а такое использование памяти крайне не эффективно. При этом программа не сможет работать с 200 элементами. Ее нужно будет переписывать.

В С++ операции ```new``` и ```delete``` предназначены для динамического распределения памяти компьютера.  Операция ```new``` выделяет память из области свободной памяти, а операция ```delete``` высвобождает выделенную память. Выделяемая память после использования должна высвобождаться, поэтому операции ```new``` и ```delete``` всегда используются парами, как открывающая и закрывающая скобки. Если не высвобождать память явно, то она освободится ресурсами ОС по завершению работы программы, но настоятельно рекомендуюется не забывать про операцию ```delete```.

```c++
// пример использования операции new
int *ptrvalue = new int;
//где ptrvalue – указатель на выделенный участок памяти типа int                  
//new – операция выделения свободной памяти под создаваемый объект.
Операция new создает объект заданного типа, выделяет ему память и возвращает указатель правильного типа на данный участок памяти. Если память невозможно выделить, например, в случае отсутствия свободных участков, то возвращается нулевой указатель, то есть указатель вернет значение 0. Выделение памяти возможно под любой тип данных: int, float,double, char и т. д.
```

```c++
// пример использования операции delete:
delete ptrvalue;
// где ptrvalue – указатель на выделенный участок памяти типа int                 
// delete – операция высвобождения памяти
```

__Нулевой указатель__

Указатель, указывающий на пустой адрес, называется нулевым. И обозначается ```Null```.
