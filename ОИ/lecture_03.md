# Общая информатика
© Бибиков Сергей, к.т.н., доцент, кафедра суперкомпьютеров и общей информатики, Самарский университет

## Лекция 3

### Немного про логические операции

В дополнение к операциям сравнения, которые возвращают __истину__ или __ложь__, стоит напомнить о логических операциях, которые являются операторами для значений типа __bool__.

В С++ существует три логические операции:
1. Логическая операция И &&. Операция бинарная.
2. Логическая операция ИЛИ ||. Операция бинарная.
3. Логическая операция НЕ ! или логическое отрицание. Операция унарная.

Логические операции образуют сложное (составное) условие из нескольких простых (два или более) условий. Эти операции упрощают структуру программного кода в несколько раз. Можно обойтись и без них, но тогда количество if увеличивается в несколько раз, в зависимости от условия. В следующей таблице  кратко охарактеризованы все логические операции в языке программирования С++, для построения логических условий.

| Операции | Обозначение |     Условие       | Краткое описание                                            |
| :------: | :---------: | :---------------- | ----------------------------------------------------------- |
|     И    |     &&      | a == 3 && b > 4   | Составное условие истинно, если истинны оба простых условия |
|    ИЛИ   |    \|\|     | a == 3 \|\| b > 4 | Составное условие истинно, если истинно, хотя бы одно из простых условий |
|     НЕ   |      !      | !( a == 3)        | Условие истинно, если a не равно 3 |

__Фишки, про которые не стоит забывать___

1. Нет смысла писать выражение типа:

```c++
bool flag = true;
int b = 5;
...
if (flag == true) {...};
if (b != 0) {...};
if (b == 0) {...};
```

Это "индийский код")

Проверять переменную можно сразу по ее значению (в некоторых случаях):
```c++
bool flag = true;
...
if (flag) {...};
if (b) {...};
if (!b) {...};
```

2. Составляя сложные логические выражение с использованием __И__ типа:
```c++
if (flag && (a>b) && (b != 2)) {...};
```
на первые места всегда стоит ставить условия, которые __не выполняются__ чаще других. Это позволит прекратить следующие проверки как бессмысленные как можно раньше.

3. Составляя сложные логические выражение с использованием __ИЛИ__ типа:
```c++
if (flag || (a>b) || (b != 2)) {...};
```
на первые места всегда стоит ставить условия, которые __выполняются__ чаще других. Это позволит прекратить следуешие проверки как бессмысленные как можно раньше.

4. В более сложных условиях с применением __И__ и __ИЛИ__ всегда можно подумать и составить условие чуть более оптимальное. Чтобы уменьшить количество проводимых проверок. Следите за логикой, если вдруг в сложные логические выражения входят условия, которые выполняются всегда или не выполняются никогда, от них нужно избавляться.

### Побитовые операции

Это определенное усложнение относительно решаемых нами задач, но про него нужно знать.

Операции выполняются только над целочисленными типами, потому что работают с битами двоичного представления числа.

В С++ существуют четыре поразрядные логические операции и две операции сдвига:

1. Поразрядное __И__, обозначение: __&__ (не путать с &&). Операция `&` сравнивает поочередно биты представления двух чисел. Если оба бита равны "1", то в ответе на соответствующем месте будет стоять "1".

__Пример:__

13 & 20

00000000.00001101 = 13

00000000.00010100 = 20

00000000.00000100 = 4


2. Поразрядное __исключающее ИЛИ__ (XOR), обозначение:  __^__. Операция `^` сравнивает поочередно биты представления двух чисел. Если оба бита разные по значению, то в ответе на соответствующем месте будет стоять "1", если одинаковые, то "0". Аналог логического `!=`.

__Пример:__

13 ^ 20

00000000.00001101 = 13

00000000.00010100 = 20

00000000.00011001 = 25

3. Поразрядное ИЛИ, обозначение:  __|__ (не путать с `||`). Операция `|` сравнивает поочередно биты представления двух чисел. Если оба бита равны "0", то в ответе на соответствующем месте будет стоять "0", иначе "1".

__Пример:__

13 | 20

00000000.00001101 = 13

00000000.00010100 = 20

00000000.00011101 = 29

4. Поразрядное НЕ, обозначение: __~__. Операция `~` унарная и превращает каждый бит представления в противоположный по значению: "0" в "1", а "1" в "0".

__Пример:__

~13

00000000.00001101 = 13

11111111.11110010 = 65 522

5. Сдвиг влево, обозначение __<<__. Операция `<<` смещает на указанное количество позиций битовое представление числа влево. Дописывает заданное количество нулей справа и стирает заданное количество символов слева. Является аналогом умножения на <img src="https://render.githubusercontent.com/render/math?math=2^{M}">, где _M_ число указанное в правой части операции (но только при соответствии бинарного представления смещению).

__Пример:__

13 << 4

00000000.00001101 = 13

00000000.11010000 = 208

6. Сдвиг вправо, обозначение __>>__. Операция `>>` смещает на указанное количество позиций битовое представление числа вправо. Дописывает заданное количество нулей слева и стирает заданное количество символов справа. Является аналогом целочисленного деления на <img src="https://render.githubusercontent.com/render/math?math=2^{M}">, где _M_ число указанное в правой части операции.

__Пример:__

13 >> 2

00000000.00001101 = 13

00000000.00000011 = 3

### Для выполнени усложнения с табличным выводом в лабораторной работе

Ознакомьтесь с информацией про использование манипуляций с выводом информации: [Форматированный ввод/вывод в С++](http://cppstudio.com/post/319/)

### Циклы в С++

Цикл - многократное повторение одного и того же набора команд подряд при выполнении заданного условия.

__FOR__

Используется обычно в случаях, когда известно общее количество повторений (итераций), которое должно быть выполнено.

```c++
// форма записи оператора цикла for:
for (/*выражение1*/; /*выражение2*/; /*выражение3*/ )
{
/*один оператор или блок операторов*/;
}
```

Если в теле цикла for должен выполнится один оператор, тогда фигурные скобки можно опустить.

`выражение1` - в этом месте описывается то, что выполняется один раз перед запуском всего цикла. Обычно тут объявляют (и инициализируют) переменную, которая выполняет роль счетчика (целочисленный тип). После выхода из цикла переменная исчезает (что объявлено в цикле, остается в цикле).

`выражение2` - здесь указывают условие, при выполнении которого будет выполняться тело цикла.

`выражение3` - тут указывается операция (или несколько), которая выполняется после каждого повторения. Обычно здесь описывается изменение счетчика после итерации.

__Примеры:__

```c++
// Классический for на 10 повторений:
for (int i = 0; i < 10; ++i) {...}

// Обратно направленный перебор. От 100 к 0:
for (int i = 100; i >= 0; --i) {...}

// С шагом, отличным от 1. От 0 до 50, четные значения:
for (int i = 0; i < 50; i += 2) {...}

// С шагом, отличным от 1. От 3 до 1000, значения, которые делятся на 3:
for (int i = 3; i <= 1000; i += 3) {...}

// Ошибка с пустым циклом. Точка с запятой делает цикл пустым:
for (int i = 0; i < 10; ++i);
{
    cout << i << endl;
}
```

__WHILE__

Используется в случае когда повторять действия нужно пока выполняется условие. Цикл с предусловием, т.е. сначала идет проверка условия, потом идет очередное повторение. При желании этот цикл может выполнять всё, что делает цикл `for` (и наоборот).

```c++
// форма записи оператора цикла while:
while (/*условие работы цикла*/ )
{
/*один оператор или блок операторов*/;
/*управление условием*/
}
```

__Примеры:__

```c++
// Обычный цикл:
while (a < b)
{
    a += 1;
}

// Реализация for через while:
int i = 0;
while (i < 10)
{
    cout << i << endl;
    ++i;
}

// Цикл с формированием условия выхода внутри:
bool flag = true;
while (flag)
{
    // Что-то происходит
    if (continue_check()) flag = false
}

// Бесконечный циклиспользовать с крайней осторожностью, всегда можно обойтись без этого, и выглядит некамильфо:
while (true)
{
    // Что-то происходит
}


// Ошибка с пустым циклом. Точка с запятой делает цикл пустым:
while (a < b);
{
    a += 1;
    cout << a << endl;
}
```

__DO WHILE__

То же самое что и `while`, но условие повторения тела цикла проверяется в конце. Поэтому тело цикла выполнится хотя бы один раз.

```c++
// форма записи оператора цикла do while:
do
{
/*один оператор или блок операторов*/;
/*управление условием*/
} while (/*условие работы цикла*/ )
```

_Внимание паскалистам: прописывается условие продолжения работы цикла, а не выхода из него!_

```c++
// Обычный цикл:
do
{
    a += 1;
} while (a < b)
```

__break и continue__

Операторы `break` и `continue` выполняют прерывание текущей итерации внутри цикла. При этом `break` выходит из всего цикла и переводит управление на следующую после цикла команду, а `continue` начинает следующую итерацию. Внимательнее при использовании этих операторов. Могут затруднить чтение.

### Исключения в С++

Исключения это инструмент, позволяющий оставаться программе работоспособной даже в условиях, приводящих к ошибке.

```c++
// Формат использования исключений
try // Начало блока отлова ошибки
{
    // ошибка может случиться и без нашего вмешательства, например при делении на 0
    // тогда исключение будет сгенерировано системой
    
    if (/*условие*/) // если мы захотим "вручную" вызвать ошибку при каком то условии
    {
        throw ЗНАЧЕНИЕ; // генерируем исключение 
    }   
}
catch(ТИП ЗНАЧЕНИЯ) // сюда передастся исключение
{
    cout << ЗНАЧЕНИЕ << endl; // некоторая обработка исключения
}
```

любая генерация исключений должна происходить в `try {}` и обрабатываться в `catch(...){}`. `ЗНАЧЕНИЕ` может быть любым объектом: целым числом, строкой, структурой и т.д. Таким инструментом можно сделать программу устойчивой, отлавливать и предсказывать ошибки логики, особенно полезно в больших проектах, над которыми работает много программистов.

__Пример:__

```c++
#include <iostream>;
using namespace std;
 
int main()
{
    setlocale(LC_ALL, "rus"); // Это команда для включения отображения кириллицы!
 
    int num1;
    int num2;
    int var = 2;
 
    while(var--)
    {
        cout << "Введите значение num1: ";
        cin >> num1;
        cout << "Введите значение num2: ";
        cin >> num2;
 
        cout << "num1 + num2 = " << num1 + num2 << endl;
        cout << "num1 / num2 = ";
 
        try
        {  
            if (num2 == 0)
            {
                throw 123; //генерировать код ошибки, например
            }
            cout << num1 / num2 << endl;   
        }
        catch(int err) // сюда передастся код ошибки
        {
            switch (err)
            case 1:
            {
                ...
                break;
            }
            case 2:
            {
                ...
                break;
            }
            ...
            case 123:
            {
                cout << str << endl;
                break;
            }
            ...
        }
 
        cout << "num1 - num2 = " << num1 - num2 << endl;
        cout << "=================================" << endl << endl;
    }
 
    cout << "Программа завершила работу!" << endl << endl;;
 
return 0;
}
```

## Конец Лекции 3

## Третье домашнее задание: 
1. Прочитать [лекцию 1](https://github.com/bbkvsrg/lecture-notes/edit/main/%D0%9E%D0%98/lecture_01.md).
2. Найти в ней опечатку или грамматическую ошибку.
3. Создать через GitHub issue c описанием ошибки.
