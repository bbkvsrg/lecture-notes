Цифровые кафедры. Цифровой медиадизайн. Модуль 2. Основы ИТ-технологий в медиадизайне

© Бибиков Сергей, к.т.н., доцент, кафедра суперкомпьютеров и общей информатики, Самарский университет

# Лекция 3. Базовые алгоритмические элементы программ: ветвление, циклы, простые структуры данных, объекты и доступ к ним.

__Содержание__

## 0 Справочные материалы по типам данных и операциям 
- [Целые числа и числа с плавающей точкой, а так же операторы ветвления и циклы](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.2/lec_1.2.ipynb)
- [Коллекции](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.3/lec_1.3.ipynb)
- [Функции](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.4/lec_1.4.ipynb)
- [Работа с файлами](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.5/lec_1.5.ipynb)


## 1. Оператор ветвления

Одним из базовых элементов в построении алгоритмов является ветвление. Когда определенные действия должны выполняться не всегда, а только при соблюдении некоторых условий, необходимо применение оператора ветвления. Для всех языков программирования оператор делает одинаковые действия, имеет схожую структуру, отображается на схеме.

![Ветвление](https://github.com/user-attachments/assets/1cfa2e45-f6f8-4e4e-9b6b-d133cfad6c12)

В операторе существуют две ветви, выбор, по какой ветви продолжится выполнение программы, происходит путем проверки условия. Если условие выполняется выбирается одна ветвь, если не выполняется - вторая. Обратите внимание, в ветви могут отсутствовать действия и операции вообще. 

Сравните: "если на рынке будет салат, купи пучок, если нет, то купи вилок капусты" и "если на рынке будет салат, купи пучок". Во втором случае при невыполнении условия не требуется делать ничего.

```
Жена отправляет мужа-программиста в магазин: - Купи батон хлеба, если
будут яйца - возьми десяток.
Муж возвращается из магазина с десятью батонами.
- Ты зачем столько хлеба купил?
- Так ведь яйца были...
```

Также часто бывает нужно применить несколько проверок каскадом. Схематически это выглядит так

![Каскадное ветвление](https://github.com/user-attachments/assets/e24a44fe-3970-43b7-86b5-177f4fb448f1)

В pyton конструкция оператора ветвления универсальна и выглядит следующим образом.

```python
if <условие>:
  <операторы>
  
[elif <условие>:
  <операторы>]
  
[else:
  <операторы>]
```
Обратите внимание, что <операторы> могут состоять из многих строк с операторами. Их нужно объединять при помощи отступов в блоки. Каждую строку, которая должна выполняться при определенных условиях начинают с отступа.

Если вы используете эту форму так

```python
if <условие>:
  <операторы>
else:
  <операторы>
```

то у вас получится первая схема.

Если 

```python
if <условие>:
  <операторы>
```

то будет реализована вторая схема.

Для реализации самого общего случая понадобятся все части конструкции.

### 1.1. Условия и булевы переменные

Каждое условие которое используется при ветвлении представляет собой выражение, возвращающее истину (```true```) или ложь (```false```). Для написания условия любой степени сложности нет необходимости заводить отдельную переменную. Для написания условий достаточно использовать операции сравнения, логические операции, а так же функции, которые возвращают булевы значения.

```python
a = 10
b = 1
```

Операции сравнения:
1. Равно
```python
a == b
```
```python
false
```

2. Не равно
```python
a != b
```
```python
true
```
   
3. Больше
```python
a > b
```
```python
true
```

4. Меньше
```python
a < b
```
```python
false
```

5. Больше либо равно
```python
a >= b
```
```python
true
```

6. Меньше либо равно
```python
a <= b
```
```python
false
```

Логические операции:
1. Логическое И
```python
false and true
```
```python
false
```

2. Логическое ИЛИ
```python
false and true
```
```python
true
```

3. Логическое отрицание
```python
not true
```
```python
false
```

Функции, которые что-то проверяют и возвращают в качестве ответа булевы означение, могут быть частью подключаемой библиотеки или быть написаны вами.

С помощью перечисленных инструментов можно составлять различные сложные условия, которые позволят сделать вашу программу гибкой и реализовать сложные алгоритмы.


Пример: написать код, который любое четное число, делящееся на 3, заменяет на 0.

```python
a = 12
if (a % 2 == 0) and (a % 3 == 0):
  a = 0
print (a)
```
```python
0
```

Пример: написать проверить, принадлежит ли число заданному сложному диапазону (-100; 3]U[5; 18].

```python
a = 12
if ((a > -100) and (a <= 3))or((a >= 5) and (a <= 18)):
  print ('число в заданном диапазоне')
else:
  print ('число не принадлежит диапазону')
```
```python
число в заданном диапазоне
```

## 2. Оператор цикла

Вторым базовым элементом для построения алгоритмов является оператор цикла. Он нужен, когда появляется необходимость многократно повторить один и тот же набор действий. При этом нам до начала работы программы может быть неизвестно сколько таких повторений понадобится. В общем смысле решение о прекращении повторений принимается до (или после) очередного набора повторяемых операций. Схематически цикл выглядит следующим образом.

![оператор цикла](https://github.com/user-attachments/assets/a020447d-8892-4c91-a88c-600959dbfd3d)

С точки зрения выполняемого кода условие определяет, когда продолжать повторения, а когда прекращать цикл и продолжать основную программу. При этом с точки зрения смысла циклы могут быть для известного количества повторений или для условий работы (или условий прекращений). В разных языках для этих смыслов могут применяться разные конструкции. В Python для цикла используются следующие конструкции, которые по сути одинаково отрабатываются, но все же несут разный смысл для программиста. Первая конструкция - цикл ```while``` (т.е. пока)

```python
while <условие>:

<операторы> 
[else:

<операторы>]
```

Пример: вывести квадраты всех нечетных чисел меньше 15, начиная с 5.

```python
a = 5
while a < 15:
  print (a*a)
  a = a + 2
```
```python
25
49
81
121
169
```

Условие здесь определяет, когда должны повторяться операторы. Условие может быть сложным.

Цикл ```for``` применяется, когда нужно перебрать все элементы какого-то множества (коллекции).

```python
for <переменная> in <коллекция>:
  <операторы> 
[else:
  <операторы>]
```

Пример: вывести квадраты всех нечетных чисел меньше 15, начиная с 5.

```python
mas = [5, 7, 9, 11, 13]
for i in mas:
  print (a*a) 
```

Основное отличие ```for``` от ```while``` - предполагается что перед началом повторений у вас есть множество объектов, над которыми нужно проводить операции. Например таким множеством может быть изображение как множество пикселей с определенными значениями.

При этом коллекцию вы можете создать непосредственно внутри цикла. Зная размеры изображения (например, 800х600) вы можете перебрать каждый пиксель. для этого нужно будет построить вложенный цикл. Кде вы будете сначала перебирать столбцы изображения, а для каждого столбца пиксели из которых он состоит. Понятно, что работать вы будете только с номерами пикселей и перебирать только эти номера, но визуализаци того, что происходит в программе всегда позволяет лучше понять, как это работает.

Пример: заменить яркость каждого полностью черного пикселя на цветном изображении на красный цвет.

```python
# здесь мы считаем каким либо образом изображение в переменную im
for i in range(im.size(0)): #здесь мы создаем коллекцию из номеров столбцов вдоль оси изображения под номером 0
  for j in range(im.size(1)): #здесь мы создаем коллекцию из номеров строк вдоль оси изображения под номером 1
    if im[i][j] == [0, 0, 0]: #здесь мы проверяем, является ли текущий пиксель изображения полностью черным
      im[i][j] = [255, 0, 0] #полностью черный пиксель заменяется на красный
```

При этом ```for``` является менее универсальным циклом, но работает существенно быстрее, если это будет иметь значение для вашей программы.

Есть еще два полезных оператора связанных с циклами ```continue``` - в месте вызова заканчивает текущее выполнение цикла и сразу переходит к следующей итерации, ```break``` - в месте вызова завершает весь цикл.
После ```else``` в обоих циклах указываются операторы, которые выполняются в случае, если выполнение цикла не было прервано оператором ```break```.

```python
for i in range(-100, -50, 5):
    if i % 3 == 0:
        print(i)
        break
else:
    print("fine")
```
```python
-90
```

Краткую справочную информацию по циклам можно найти по [ссылке](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.3/lec_1.3.ipynb).

## 3. Простые структуры данных

Python как язык создавался как более удобная версия C++ для научных вычислений и удобного проектирования. Его разработка включила в себя множество дополнительных удобств, которые по свому использованию отличаются от класических алгоритмических подходов в других языках. Так появился стиль python. Который предполагает, что вы будете предпочитать эти удобства чаще классических способов. Это касается и обращения с простыми структурами данных, которые реализованы прямо в базовой версии языка, для их создания не нужно подключать библиотеки.

С такими структурами мы немного познакомились на предыдущих лекциях. К ним я отношу коллекции, которые включают в себя списки, словари, кортежи, множества, строки и массивы. Для начального изучения нам будет достаточно работы со списками. Основная идея стиля python заключается в том, что вместо того чтобы перебирать все элементы множества с последующей проверкой, подходит нам этот элемент или нет, можно более эффективным способом - сразу сформировать список нужных нам элементов.

![types](https://github.com/user-attachments/assets/5a1ce61d-ad86-4469-9659-20efdefb3225)

Как создавать списки мы кратко рассмотрели на предыдущих лекциях.

Теперь рассмотрим разные методы работы со списками чуть подробнее.

### 3.1. Обращение к элементам списка

Обращение по номеру

```python
l = [1, 2, 3, 5, 7, 11, 13, 17]

print(l[0], l[2], l[len(l) - 1])

print(l[-1], l[-2], l[-len(l)])
```
```python
1 3 17
17 13 1
```

Обращение по срезу (от и до)

list[start:stop:step]

```python
l = [1, 2, 3, 5, 7, 11, 13, 17]
print(l[1:3])
```
```python
[2, 3]
```
---
```python
print(l[1:6:2])
[2, 5, 11]
print(l[1:6:-2])
```
```python
[]
```
---
```python
print(l[3:])
```
```python
[5, 7, 11, 13, 17]
```
---
```python
print(l[:4])
```
```python
[1, 2, 3, 5]
```
---
```python
print(l[:])
```
```python
[1, 2, 3, 5, 7, 11, 13, 17]
```
---
```python
print(l[:-4])
```
```python
[1, 2, 3, 5]
```
---
```python
print(l[::2])
```
```python
[1, 3, 7, 13]
```
---
```python
print(l[::-2])
```
```python
[17, 11, 5, 2]
```
---
```python
print(l[20:25])
```
```python
[]
```
---
```python
print(l[-25:-20])
```
```python
[]
```
---
```python
print(l[-20:20])
```
```python
[1, 2, 3, 5, 7, 11, 13, 17]
```
---
```python
print(l[::-1])
```
```python
[17, 13, 11, 7, 5, 3, 2, 1]
```
---
```python
l1 = [1, [2, 3], 4]
l2 = l1[::-1]
print(l1)
print(l2)
```
```python
[1, [2, 3], 4]
[4, [2, 3], 1]
```
---
```python
l2[1][0] = 11
print(l1)
print(l2)
```
```python
[1, [11, 3], 4]
[4, [11, 3], 1]
```
---

Таким образом, если мы представим изображение в виде списка (или подключив популрную библиотеку ```numpy``` в виде многомерного массива - объект из этой библиотеки на основе списков), то мы сможем с легкостью работать со всем изображением сразу, с его фрагментами, слоями (а также слоями любого другого представления изображения, ведь мы не ограничены RGB).

Кроме того при помощи стиля python можно легко использовать логическую индексацию - это когда вместо прямых индексов мы указываем условие, по которомы принимается решение, подходит нам этот элемент списка (например, пискель) или нет.

```python
%matplotlib inline #The line above is necesary to show Matplotlib's plots inside a Jupyter Notebook

import cv2
import numpy as np
from matplotlib import pyplot as plt

#Import image
image = cv2.imread("c:/dat_an/1.jpg")
image = image[:, :, (2,1,0)] #Потому что CV2 считывает изображения в порядке BGR

#Show the image with matplotlib
plt.imshow(image)
plt.show()
```

![image](https://github.com/user-attachments/assets/041722e6-5d9d-46f9-bceb-561891defded)

```python
im1 = image.copy()
print(im1.shape)
im1[:, :, 2] = 0 #Удаляем синий канал
plt.imshow(im1)
```

![image](https://github.com/user-attachments/assets/d554807e-6ca6-46f5-99d8-5514eb3ca2d5)


```python
im2 = image.copy()
im2[200:800, 300:900, :] = 0 #Стираем область
plt.imshow(im2)
```

![image](https://github.com/user-attachments/assets/67f814c9-5914-4458-adc5-f593876bd269)


```python
im3 = image.copy()
im3[im3[:, :, 0] < 50] = [255, 255, 255] #Заменяем область, в которой значение красного канала <50, на белый цвет с применением логического индексирования, например для препарирования изображения
plt.imshow(im3)
```

![image](https://github.com/user-attachments/assets/b7c07e90-a570-41b1-b668-5153b09234ac)

В отличие от других языков программирования, здесь не нужно организовывать проход по всем пикселям изображения отдельно. Можно работать сразу с ними со всеми. Таким образом становится очень просто работать с масками для изображений. Причем как с бинарными, которые обозначают принадлежность каждого пикселя к области интереса, так и с масками градациями, которые могут обозначать в какой степени применять то или иное преобразование к пикселю.

Главная идея при работе со срезами - размер того, что вы пытаетесь записать, должен совпадать по размеру целевой области. Пример на простом множестве
```python
l = [1, 2, 3, 5, 7, 11, 13, 17]
print(l)
l[1:6:2] = [55, 66, 77]
print(l)
```
```python
[1, 2, 3, 5, 7, 11, 13, 17]
[1, 55, 3, 66, 7, 77, 13, 17]
```

Пример с изображением
```python
im3 = image.copy()
im3[300:900, 300:900, :] = im3[600:1200, 600:1200, :] #Мы скопировали часть изображения в другое место изображения
plt.imshow(im3)
```
![image](https://github.com/user-attachments/assets/85dfb23e-6186-4d31-9bdc-ff3a90056a89)


### 3.2. Методы работы со списками

Здесь перечислим только базовые операции, чтобы вы знали, что можно делать со списками. Примеры этих операция можно посмотреть по [ссылке](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.3/lec_1.3.ipynb) и по [этой ссылке](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html)
1. Добавление элемента в конец списка ```l.append(<добавляемый элемент>)```
2. Очистка списка ```l.clear()```
3. Поверхностная копия ```l2 = l1.copy()```
4. Количество элементов с заданным значением ```res = l.count(5)```
5. Расширение списка методом extend ```l1.extend(l2)```
6. Расширение списка методом через + ```l3 = l1 + l2```
7. Поиск элемента ```i = l.index(1, 2, 5)```
8. Вставка элемента в заданную позицию ```l.insert(2, 22)```
9. Извлечение i-го элемента ```val = l.pop(-2)```
10. Удаление первого встретившегося по значению элемента ```l.remove(1)```
11. Переворачивание списка ```l.reverse()```
12. Сортировка списка, сортировка списка функцией sorted() ```l.sort()``` ```l2 = sorted(l1)```
13. min и max ```val = min(l)``` ```val = max(l)```
14. Функция map ```l2 = list(map(m.sin, l1))```
15. Перебор элементов списка ```for n, m in zip(name, mark)```

## 4. Объекты и доступ к ним

До создания собственных классов и объектов в рамках нашего короткого курса не доберемся - слишком мало времени. Но как работать с объектами из различных библиотек посмотрим. Библиотеки содержат в себе различные функции и классы, которые при использовании в вашей программе порождают экземпляры. Описание класса в библиотеке подразумевает информацию не только о том, какая информация хранится внутри каждого экземпляра (обънкта), но и какие функции применимы для этого экзепляра. 

Доступ к функциям и внутренним полям объекта осуществляется чаще всего с использованием обычной точки - <объект>.<свойство или метод/функция>. Если это просто внутреннее поле, то работать с ним можно как с обычной переменной, то есть можно записывать что-то наподобие ```h, w, d = im.shape```. Если это доступ к методу, который можно применить к данному объекту, то это выглядит наподобие ```a = vec.sort()```.

Если вы используете какую-то более продвинутую среду программирования, то в редакторе кода после написания ```.``` после объекта будут появляться подсказки о том, что из встроенных методов вы можете вызвать. Если вы работаете в google.colab или jupyter lab, то таких подсказок может и не быть. Тогда всю информацию о том, что вы можете применить, нужно искать в онлайн документации для данной библиотеки.

Пример
```python
%matplotlib inline
#The line above is necesary to show Matplotlib's plots inside a Jupyter Notebook

import cv2
import numpy as np
from matplotlib import pyplot as plt

#Import image
image = cv2.imread("c:/dat_an/1.jpg")
image = image[:, :, :]
print(image.shape)

#Show the image with matplotlib
plt.imshow(image[:, :, (2, 1, 0)])
plt.show()
```
![image](https://github.com/user-attachments/assets/c42791ea-1e03-4f8c-8dee-10d7d043b171)

```python
im5 = image.copy()
im5 = cv2.cvtColor(im5,cv2.COLOR_BGR2HSV)
lower = np.array([110, 200, 50])
upper = np.array([359,255,255])
#mask = S.copy()
mask = cv2.inRange(im5, lower, upper)
print(mask)
plt.imshow(mask)
```

![image](https://github.com/user-attachments/assets/1a795235-ec9b-46a7-b6c5-f8e965e2c811)

```python
im5[mask == 0, 1] = 0
im5 = cv2.cvtColor(im5,cv2.COLOR_HSV2RGB)
plt.imshow(im5)
```

![image](https://github.com/user-attachments/assets/902adde7-101d-4dc3-8a78-504e8e8fd8d4)
