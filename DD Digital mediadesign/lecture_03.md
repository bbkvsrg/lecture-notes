Цифровые кафедры. Цифровой медиадизайн. Модуль 2. Основы ИТ-технологий в медиадизайне

© Бибиков Сергей, к.т.н., доцент, кафедра суперкомпьютеров и общей информатики, Самарский университет

# Лекция 3. Базовые алгоритмические элементы программ: ветвление, циклы, простые структуры данных, объекты и доступ к ним.

__Содержание__

## 0 Справочные материалы по типам данных и операциям 
- [Целые числа и числа с плавающей точкой](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.2/lec_1.2.ipynb)
- [Коллекции](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.3/lec_1.3.ipynb)
- [Функции](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.4/lec_1.4.ipynb)
- [Работа с файлами](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.5/lec_1.5.ipynb)


## 1 Оператор ветвления

Одним из базовых элементов в построении алгоритмов является ветвление. Когда определенные действия должны выполняться не всегда, а только при соблюдении некоторых условий, необходимо применение оператора ветвления. Для всех языков программирования оператор делает одинаковые действия, имеет схожую структуру, отображается на схеме.

![Ветвление](https://github.com/user-attachments/assets/1cfa2e45-f6f8-4e4e-9b6b-d133cfad6c12)

В операторе существуют две ветви, выбор, по какой ветви продолжится выполнение программы, происходит путем проверки условия. Если условие выполняется выбирается одна ветвь, если не выполняется - вторая. Обратите внимание, в ветви могут отсутствовать действия и операции вообще. 

Сравните: "если на рынке будет салат, купи пучок, если нет, то купи вилок капусты" и "если на рынке будет салат, купи пучок". Во втором случае при невыполнении условия не требуется делать ничего.

```
Жена отправляет мужа-программиста в магазин: - Купи батон хлеба, если
будут яйца - возьми десяток.
Муж возвращается из магазина с десятью батонами.
- Ты зачем столько хлеба купил?
- Так ведь яйца были...
```

Также часто бывает нужно применить несколько проверок каскадом. Схематически это выглядит так

![Каскадное ветвление](https://github.com/user-attachments/assets/e24a44fe-3970-43b7-86b5-177f4fb448f1)

В pyton конструкция оператора ветвления универсальна и выглядит следующим образом.

```python
if <условие>:
  <операторы>
  
[elif <условие>:
  <операторы>]
  
[else:
  <операторы>]
```
Обратите внимание, что <операторы> могут состоять из многих строк с операторами. Их нужно объединять при помощи отступов в блоки. Каждую строку, которая должна выполняться при определенных условиях начинают с отступа.

Если вы используете эту форму так

```python
if <условие>:
  <операторы>
else:
  <операторы>
```

то у вас получится первая схема.

Если 

```python
if <условие>:
  <операторы>
```

то будет реализована вторая схема.

Для реализации самого общего случая понадобятся все части конструкции.

### 1.1 Условия и булевы переменные

Каждое условие которое используется при ветвлении представляет собой выражение, возвращающее истину (```true```) или ложь (```false```). Для написания условия любой степени сложности нет необходимости заводить отдельную переменную. Для написания условий достаточно использовать операции сравнения, логические операции, а так же функции, которые возвращают булевы значения.

```python
a = 10
b = 1
```

Операции сравнения:
1. Равно
```python
a == b
```
```python
false
```

2. Не равно
```python
a != b
```
```python
true
```
   
3. Больше
```python
a > b
```
```python
true
```

4. Меньше
```python
a < b
```
```python
false
```

5. Больше либо равно
```python
a >= b
```
```python
true
```

6. Меньше либо равно
```python
a <= b
```
```python
false
```

Логические операции:
1. Логическое И
```python
false and true
```
```python
false
```

2. Логическое ИЛИ
```python
false and true
```
```python
true
```

3. Логическое отрицание
```python
not true
```
```python
false
```

Функции, которые что-то проверяют и возвращают в качестве ответа булевы означение, могут быть частью подключаемой библиотеки или быть написаны вами.

С помощью перечисленных инструментов можно составлять различные сложные условия, которые позволят сделать вашу программу гибкой и реализовать сложные алгоритмы.


Пример: написать код, который любое четное число, делящееся на 3, заменяет на 0.

```python
a = 12
if (a % 2 == 0) and (a % 3 == 0):
  a = 0
print (a)
```
```python
0
```

Пример: написать проверить, принадлежит ли число заданному сложному диапазону (-100; 3]U[5; 18].

```python
a = 12
if ((a > -100) and (a <= 3))or((a >= 5) and (a <= 18)):
  print ('число в заданном диапазоне')
else:
  print ('число не принадлежит диапазону')
```
```python
число в заданном диапазоне
```

## 2 Оператор цикла

Вторым базовым элементом для построения алгоритмов является оператор цикла. Он нужен, когда появляется необходимость многократно повторить один и тот же набор действий. При этом нам до начала работы программы может быть неизвестно сколько таких повторений понадобится. В общем смысле решение о прекращении повторений принимается до (или после) очередного набора повторяемых операций. Схематически цикл выглядит следующим образом.

![оператор цикла](https://github.com/user-attachments/assets/a020447d-8892-4c91-a88c-600959dbfd3d)

С точки зрения выполняемого кода условие определяет, когда продолжать повторения, а когда прекращать цикл и продолжать основную программу. При этом с точки зрения смысла циклы могут быть для известного количества повторений или для условий работы (или условий прекращений). В разных языках для этих смыслов могут применяться разные конструкции. В Python для цикла используются следующие конструкции, которые по сути одинаково отрабатываются, но все же несут разный смысл для программиста. Первая конструкция - цикл ```while``` (т.е. пока)

```python
while <условие>:

<операторы> 
[else:

<операторы>]
```

Пример: вывести квадраты всех нечетных чисел меньше 15, начиная с 5.

```python
a = 5
while a < 15:
  print (a*a)
  a = a + 2
```
```python
25
49
81
121
169
```

Условие здесь определяет, когда должны повторяться операторы. Условие может быть сложным.

Цикл ```for``` применяется, когда нужно перебрать все элементы какого-то множества (коллекции).

```python
for <переменная> in <коллекция>:
  <операторы> 
[else:
  <операторы>]
```

Пример: вывести квадраты всех нечетных чисел меньше 15, начиная с 5.

```python
mas = [5, 7, 9, 11, 13]
for i in mas:
  print (a*a) 
```

Основное отличие ```for``` от ```while``` - предполагается что перед началом повторений у вас есть множество объектов, над которыми нужно проводить операции. НАпример таким множеством может быть изображение как множество пикселей с определенными значениями.

При этом коллекцию вы можете создать непосредственно внутри цикла. Зная размеры изображения (например, 800х600) вы можете перебрать каждый пиксель. для этого нужно будет построить вложенный цикл. Кде вы будете сначала перебирать столбцы изображения, а для каждого столбца пиксели из которых он состоит. Понятно, что работать вы будете только с номерами пикселей и перебирать только эти номера, но визуализаци того, что происходит в программе всегда позволяет лучше понять, как это работает.

Пример: заменить яркость каждого полностью черного пикселя на цветном изображении на красный цвет.

```python
# здесь мы считаем каким либо образом изображение в переменную im
for i in range(im.size(0)): #здесь мы создаем коллекцию из номеров столбцов вдоль оси изображения под номером 0
  for j in range(im.size(1)): #здесь мы создаем коллекцию из номеров строк вдоль оси изображения под номером 1
    if im[i][j] == [0, 0, 0]: #здесь мы проверяем, является ли текущий пиксель изображения полностью черным
      im[i][j] = [255, 0, 0] #полностью черный пиксель заменяется на красный
```

При этом ```for``` является менее универсальным циклом, но работает существенно быстрее, если это будет иметь значение для вашей программы.

Есть еще два полезных оператора связанных с циклами ```continue``` - в месте вызова заканчивает текущее выполнение цикла и сразу переходит к следующей итерации, ```break``` - в месте вызова завершает весь цикл.
После ```else``` в обоих циклах указываются операторы, которые выполняются в случае, если выполнение цикла не было прервано оператором ```break```.

```python
for i in range(-100, -50, 5):
    if i % 3 == 0:
        print(i)
        break
else:
    print("fine")
```
```python
-90
```

## 3 Простые структуры данных

![types](https://github.com/user-attachments/assets/5a1ce61d-ad86-4469-9659-20efdefb3225)

Еще раз рассмотрим эту картинку. Типов данных всяких много. Но нам для упрощения в нашем курсе понадобятся целые числа, числа с плавающей точкой, и коллекции (всякие разные).

"Изменяемые" означает, что при изменении объекта он не переписывается заново. "Неизменяемые" требует пересоздания объекта в измененном виде и записи его в ту же переменную.

Целые числа самый лучший формат представления данных потому, что обладают абсолютной точностью, в Python для них доступна длинная арифметика (можно очень большие числа получать и хранить).

```python
-5
9900000
0
```

Числа с плавающей точкой позволяют хранить с определенной точностью числа с дробной частью. По сравнению с целыми они ограничены по объему занимаемой памяти (им недоступна длинная арифметика) хоть и могут принимать ОЧЕНЬ большие или маленькие значения. При работе с такими числами возможно накопление неточности (потому что они иногда принимают только приблизительное значение), что может приводить к вычислительной ошибке. Но иногда без них просто невозможно обойтись при представлении определенных данных.

```python
0.6
999.9
-999.6e-99
3.4e+88
```

Строки как отдельный случай коллекций полезны нам с точки зрения ввода и вывода информации.

```python
'Строка в одинарных кавычках, не путайте с апострофом \`'
"Тоже строка но в двойных кавычках"
```

Коллекции нужны для представления больших наборов данных, например, изображений в виде массива значений. Например списки:

```python
[0, 1, 2]
[[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]
[1, 't', -3.0]
```

Есть еще уникальный тип данных, с которым мы имеем дело - None - отсутствие данных, пустота, в переменной хранится ничто.
```python
None
```

Зачем нужно хранить пустоту? Это может пригодиться, когда содержимого у вас еще нет, а вот форма для хранения уже есть. Обычно ```None``` показывает что тут отсутствуют данные, хотя в других таких же местах они есть. Например собирали базу данных по продажам и был какой-нибудь сбой связи. Тогда в продажах, например, газировки в этот день может стоять ```None``` и это будет обозначать не отсутствие продаж (тогда был бы ```0```) а отсутствие информации вообще. В анализе данных это может быть важным, но как правило пустое место сильно мешает математической обработке и его чем-либо заполняют, в зависимости от ситуации, например теми же нулями.

## 4 Операции

Операции с числами естественным образом совпадают с тем, что мы привыкли делать в рамках школьного курса. Сложение и вычитание, умножение и деление, деление нацело и получение остатка от деления. Все эти операции приведены в справочных материалах в разделе 0, не стесняйтесь туда подсматривать, это очень полезно. Так же вы можете понять многие вещи про Python, про которые я не рассказываю в рамках модуля.

### 4.1 Сложение и вычитание

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a + b
print (f)
f = a - c
print (f)
f = c - d
print (f)
```

Как видите, эти операции записываются совершенно привычным образом. И результат будет предсказуемый.

```python
23 <class 'int'>
5.5 <class 'float'>
4.4999 <class 'float'>
```

### 4.2 Умножение

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a * b
print (f)
f = a * c
print (f)
f = c * d
print (f)
```

А вот тут среди предсказуемого результата нам попадается странное

```python
130
45.0
0.00045000000000000004
```

С чем связан тот факт, что мы получили неточное значение при перемножении? Откуда взялась эта добавка? Дело в том, что числа с плавающей точкой (те которые с дробной частью) чаще всего хранят не точное значение, а приближенное. И часто эта несточность появляется в результатах вычислений. Так десятичная запись ```0.2``` для нас является конечной, но в двоичном виде она будет выглядеть как ```0.00110011001...```, то есть будет бесконечной двоичной дробью. А в памяти компьютера мы не можем хранить ничего бесконечного. Поэтому запись где-то обрежется и мы столкнемся с _приближенным_ значением, которое и даст при вычислениях достаточно точный, но _приближенный_ результат. 

Отсюда вывод: **если хотите получить максимальную точность, работайте с целыми числами**.

### 4.3 Деление

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a / b
print (f)
f = b / a
print (f)
f = c / d
print (f)
```
Тут стоит обратить внимание, что деление всегда дает нам в ответе числа с плавающей точкой.


```python
0.7692307692307693
1.3
45000.0
```
#### 4.3.1 Целочисленное деление

Когда мы хоти получить целую часть от деления, можно сразу выполнять целочисленное деление ```//```

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a // b
print (f)
f = b // a
print (f)
f = c // d
print (f)
```

При делении целого числа на целое, ответ тоже будет целым. А вот если у нас есть два числа с плавающей точкой, то и результат будет таким же. Вы всегда можете это проверить в своем блокноте.

```python
0
1
44999.0
```

#### 4.3.2 Остаток от деления

Парная операция для целочисленного деления - получение остатка от деления ```%```. Но и тут есть хитрая часть.

```python
a = -11
b = 5

q = a // b
r = a % b
print(q, r)
```

Ответ будет

```python
-3 4
```

Потому что результат целочисленного деления должен быть меньше или равен точному ответу (в данном случае меньше, чем ```-2.2```), при этом остаток должен быть того же знака что и делитель. Лучше всего запомнить, что тут могут быть хитрости, и если вы столкнетесь с такой ситуацией, вспомните и поищите объяснение. Сравните

```python
a = -11
b = -5

q = a // b
r = a % b
print(q, r)
```

Ответ будет

```python
2 -1
```

### 4.4 Операция унарного минуса

Это просто смена знака у значения

```python
a = -11
b = -a
print(b)
```

Ответ предсказуемый

```python
11
```

### 4.5 Возведение в степень

Для возведения в степень используется знак ```**```. Степень может быть нецелой и отрицательной. При этом могут получаться комплексные числа
```python
a = 10
b = -13
c = 4.5
d = 0.0001
f = a ** b
print (f)
f = b ** a
print (f)
f = c ** d
print (f)
f = (-4.6)**(-5.5)
print (f)
```

Получим

```python
1e-13
137858491849
1.0001504190514887
(-5.546033816344401e-19+0.00022637680479046734j)
```

Следует понимать, что эти операции, как и в обычной математике, имеют свои приоритеты: сначала будет выполняться возведение в степень, потом унарный минус, потом умножение с делением, последним сложение и вычитание. Для упрощения чтения ваших математических формул используйте нужное количество скобок и пробелов. Ознакомится с руководством по правилам _написания_ можно по [ссылке](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html).

