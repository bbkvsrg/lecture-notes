Цифровые кафедры. Цифровой медиадизайн. Модуль 2. Основы ИТ-технологий в медиадизайне

© Бибиков Сергей, к.т.н., доцент, кафедра суперкомпьютеров и общей информатики, Самарский университет

# Лекция 2. Базовые понятия программирования: структура программ, библиотеки, переменные, типы данных, основные операции, работа с памятью компьютера.

__Содержание__

## 0 Справочные материалы по типам данных и операциям 
- [Целые числа и числа с плавающей точкой](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.2/lec_1.2.ipynb)
- [Коллекции](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.3/lec_1.3.ipynb)
- [Функции](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.4/lec_1.4.ipynb)
- [Работа с файлами](https://github.com/bbkvsrg/lecture-notes/blob/main/DD%20Digital%20mediadesign/suppl/lec_1.5/lec_1.5.ipynb)


## 1 Принцип программирования

Взять числа из памяти, провести с ними вычисления и получить результат, записать результат в память для дальнейшего использования.

Чтобы взять что-то из памяти, нужно сначала положить что-то в память.

Как работает память компьютера: огромный набор ячеек с адресами в которых чтото хранится. Чтобы что-то сохранить в память нужно запомнить адрес начала используемого для хранения места и общий размер требуемого для хранения места. Адрес использовать человеку неудобно - длинный набор цифр, поэтому в программах мы используем **имя** вместо адреса. Размер хранимого очень важная вещь, чтобы не залезть на другие хранимые данные. Размер определяется **типом данных** (но за этим следит python). Так появляется понятие переменной - проименованная область памяти, обращение к которой при написании программы возможно по имени.

Как выглядит работа с переменными в python:
Отдельное объявление переменной в отличие от других языков не требуется.
<имя переменной> = значение

```python
a = 10
```

Символ "=" означает операцию присваивания. То что справа (как правило число или какой-то объект) записывается в ячейку с именем, которое указано слева. При необходимости выделяется новая область памяти (побольше или поменьше).


После этого в памяти появляется набор из нескольких ячеек, которые хранят целое число 10. Адрес начальной ячейки и тип данных записывается в специальную таблицу напротив имени "a".

Значение определяет тип данных, которые хранит переменная. В одной переменной в один момент времени хранится только одно значение или объект, но на протяжении работы программы там могут храниться разные значения разных типов.

```python
a = 10
a = 2.4
a = "Вжух!"
```

![types](https://github.com/user-attachments/assets/5a1ce61d-ad86-4469-9659-20efdefb3225)

Как работает вычисление на основе других переменных?

Как только интерпретатор натыкается на имя переменной, он лезет в таблицу, находит адрес, соответствующий имени переменной, считывает оттуда информацию и проводит над ней нужные манипуляции, если может, конечно.

```python
a = 10
b = 2.4
c = a + 10.45 + 3*b
```

Залезает по имени ```b``` в таблицу и находит адрес, достает из оперативной памяти по этому адресу число ```2.4```, и подставляет его в выражение ```3 * b```. Получает ```3 * 2.4```. Процессор вычисляет это выражение, получает ответ 7.2. Подставляет его в выражение ```10.45 + <ответ>```. Вычисляет и получает ответ ```17.65```. Залезает по имени ```a``` в таблицу и находит адрес, достает из оперативной памяти по этому адоресу число ```10```, и подставляет его в выражение ```a + <ответ>```. Получает выражение ```10 + 17.65```. Вычисляет и получает ответ ```27.65```. Это значение записывается в память в переменную с именем ```c```.

Как работают функции?
Функции работают по тому же принципу как и их математический аналог.

```python
import math
a = -3.51
print(math.sin(abs(a)))
```

Функция ```print()``` предназначена для вывода на экран аргумента (того, что в нее передается в круглых скобках). А там находится еще одна функция, которая и запускается. Функция ```math.sin()``` вычисляет синус от переданного аргумента. А там находится функция ```abs()```, которая вычисляет модуль своего аргумента. В качестве аргумента туда передается значение переменной ```a = -3.51```.

Теперь этот каскад вызовов начинает разворачиваться в обратную строну. Функция ```abs()``` вычисляет модуль и **возвращает** на место своего вызова ```3.51```. Функция ```math.sin(3.51)``` проводит вычисления и возвращает в точку вызова ```-0.36013009947196817```. Функция ```print(-0.36013009947196817)``` выводит на экран это значение в формате по умолчанию

```python
-0.36013009947196817
```

## 2 Бибилиотеки

Вы не первые люди, кто изучает программирование и решает свои задачи. Люди до вас решили очень много задач и эти решения были настолько хороши, что их превратили в библиотеки, доступные для использования любым другим программистом. Количество библиотек на Python огромно. Они перекрывают практически любые потребности прикладного программирования, любая ваша серьезная задача скорее всего частично или полностью кем-то уже решена.

Подключение библиотек целиком.

import <имя библиотеки> [as <короткий псевдоним для удобства>]

Сравните:
```python
import numpy
a = numpy.array([[1,2,3,4],[3,4,6,7],[5,9,0,5]])
```
и
```python
import numpy as np
a = np.array([[1,2,3,4],[3,4,6,7],[5,9,0,5]])
```

Когда вы пишете полное название библиотеки 10 раз это не сильно раздражает, но когда это нужно сделать 1000 раз, короткие названия сильно приятнее.

Подключение отдельных функций из библиотек.
Когда вы точно знаете, что из бибилиотеки вам нужно в программе. Происходит сильно быстрее, чем тащить всю бибилиотеку.

from <название библиотеки> import <название(-я) объекта(-ов)>

```python
from numpy.linalg import solve, inv
```

С учетом того, что однажды выполненная ячейка блокнота вносит изменения, которые сохраняются на протяжении всей сессии (мы говорим о сессии Google colab), приянто все подключения библиотек выполнять в самом начале программы в отдельной ячейке и перезапускать ее только при добавлении новых строк с подключением библиотек.

## 3 Типы данных

![types](https://github.com/user-attachments/assets/5a1ce61d-ad86-4469-9659-20efdefb3225)

Еще раз рассмотрим эту картинку. Типов данных всяких много. Но нам для упрощения в нашем курсе понадобятся целые числа, числа с плавающей точкой, и коллекции (всякие разные).

"Изменяемые" означает, что при изменении объекта он не переписывается заново. "Неизменяемые" требует пересоздания объекта в измененном виде и записи его в ту же переменную.

Целые числа самый лучший формат представления данных потому, что обладают абсолютной точностью, в Python для них доступна длинная арифметика (можно очень большие числа получать и хранить).

```python
-5
9900000
0
```

Числа с плавающей точкой позволяют хранить с определенной точностью числа с дробной частью. По сравнению с целыми они ограничены по объему занимаемой памяти (им недоступна длинная арифметика) хоть и могут принимать ОЧЕНЬ большие или маленькие значения. При работе с такими числами возможно накопление неточности (потому что они иногда принимают только приблизительное значение), что может приводить к вычислительной ошибке. Но иногда без них просто невозможно обойтись при представлении определенных данных.

```python
0.6
999.9
-999.6e-99
3.4e+88
```

Строки как отдельный случай коллекций полезны нам с точки зрения ввода и вывода информации.

```python
'Строка в одинарных кавычках, не путайте с апострофом \`'
"Тоже строка но в двойных кавычках"
```

Коллекции нужны для представления больших наборов данных, например, изображений в виде массива значений. Например списки:

```python
[0, 1, 2]
[[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]
[1, 't', -3.0]
```

Есть еще уникальный тип данных, с которым мы имеем дело - None - отсутствие данных, пустота, в переменной хранится ничто.
```python
None
```

Зачем нужно хранить пустоту? Это может пригодиться, когда содержимого у вас еще нет, а вот форма для хранения уже есть. Обычно ```None``` показывает что тут отсутствуют данные, хотя в других таких же местах они есть. Например собирали базу данных по продажам и был какой-нибудь сбой связи. Тогда в продажах, например, газировки в этот день может стоять ```None``` и это будет обозначать не отсутствие продаж (тогда был бы ```0```) а отсутствие информации вообще. В анализе данных это может быть важным, но как правило пустое место сильно мешает математической обработке и его чем-либо заполняют, в зависимости от ситуации, например теми же нулями.

## 4 Операции

Операции с числами естественным образом совпадают с тем, что мы привыкли делать в рамках школьного курса. Сложение и вычитание, умножение и деление, деление нацело и получение остатка от деления. Все эти операции приведены в справочных материалах в разделе 0, не стесняйтесь туда подсматривать, это очень полезно. Так же вы можете понять многие вещи про Python, про которые я не рассказываю в рамках модуля.

### 4.1 Сложение и вычитание

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a + b
print (f)
f = a - c
print (f)
f = c - d
print (f)
```

Как видите, эти операции записываются совершенно привычным образом. И результат будет предсказуемый.

```python
23 <class 'int'>
5.5 <class 'float'>
4.4999 <class 'float'>
```

### 4.2 Умножение

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a * b
print (f)
f = a * c
print (f)
f = c * d
print (f)
```

А вот тут среди предсказуемого результата нам попадается странное

```python
130
45.0
0.00045000000000000004
```

С чем связан тот факт, что мы получили неточное значение при перемножении? Откуда взялась эта добавка? Дело в том, что числа с плавающей точкой (те которые с дробной частью) чаще всего хранят не точное значение, а приближенное. И часто эта несточность появляется в результатах вычислений. Так десятичная запись ```0.2``` для нас является конечной, но в двоичном виде она будет выглядеть как ```0.00110011001...```, то есть будет бесконечной двоичной дробью. А в памяти компьютера мы не можем хранить ничего бесконечного. Поэтому запись где-то обрежется и мы столкнемся с _приближенным_ значением, которое и даст при вычислениях достаточно точный, но _приближенный_ результат. 

Отсюда вывод: **если хотите получить максимальную точность, работайте с целыми числами**.

### 4.3 Деление

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a / b
print (f)
f = b / a
print (f)
f = c / d
print (f)
```
Тут стоит обратить внимание, что деление всегда дает нам в ответе числа с плавающей точкой.


```python
0.7692307692307693
1.3
45000.0
```
#### 4.3.1 Целочисленное деление

Когда мы хоти получить целую часть от деления, можно сразу выполнять целочисленное деление ```//```

```python
a = 10
b = 13
c = 4.5
d = 0.0001
f = a // b
print (f)
f = b // a
print (f)
f = c // d
print (f)
```

При делении целого числа на целое, ответ тоже будет целым. А вот если у нас есть два числа с плавающей точкой, то и результат будет таким же. Вы всегда можете это проверить в своем блокноте.

```python
0
1
44999.0
```

#### 4.3.2 Остаток от деления

Парная операция для целочисленного деления - получение остатка от деления ```%```. Но и тут есть хитрая часть.

```python
a = -11
b = 5

q = a // b
r = a % b
print(q, r)
```

Ответ будет

```python
-3 4
```

Потому что результат целочисленного деления должен быть меньше или равен точному ответу (в данном случае меньше, чем ```-2.2```), при этом остаток должен быть того же знака что и делитель. Лучше всего запомнить, что тут могут быть хитрости, и если вы столкнетесь с такой ситуацией, вспомните и поищите объяснение. Сравните

```python
a = -11
b = -5

q = a // b
r = a % b
print(q, r)
```

Ответ будет

```python
2 -1
```

### 4.4 Операция унарного минуса

Это просто смена знака у значения

```python
a = -11
b = -a
print(b)
```

Ответ предсказуемый

```python
11
```

### 4.5 Возведение в степень

Для возведения в степень используется знак ```**```. Степень может быть нецелой и отрицательной. При этом могут получаться комплексные числа
```python
a = 10
b = -13
c = 4.5
d = 0.0001
f = a ** b
print (f)
f = b ** a
print (f)
f = c ** d
print (f)
f = (-4.6)**(-5.5)
print (f)
```

Получим

```python
1e-13
137858491849
1.0001504190514887
(-5.546033816344401e-19+0.00022637680479046734j)
```

Следует понимать, что эти операции, как и в обычной математике, имеют свои приоритеты: сначала будет выполняться возведение в степень, потом унарный минус, потом умножение с делением, последним сложение и вычитание. Для упрощения чтения ваших математических формул используйте нужное количество скобок и пробелов. Ознакомится с руководством по правилам _написания_ можно по [ссылке](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html).

