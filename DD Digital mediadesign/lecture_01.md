Цифровые кафедры. Цифровой медиадизайн. Модуль 2. Основы ИТ-технологий в медиадизайне

© Бибиков Сергей, к.т.н., доцент, кафедра суперкомпьютеров и общей информатики, Самарский университет

# Лекция 1. Информационные инструменты: существующие языки программирования, средства совместной разработки, облачные сервисы, инструменты планирования.

__Содержание__
1.   [Цели модуля](#1-цели-модуля)
2.   [Формат модуля](#2-формат-модуля)
3.   [Компьютер как вычислитель](#3-компьютер-как-вычислитель)
4.   [Ограничения компьютера](#4-ограничения-компьютера)
5.   [Программа](#5-программа)
6.   [Примеры известных языков программирования](#6-примеры-известных-языков-программирования)
7.   [Процесс программирования](#7-процесс-программирования)
8.   [Системы контроля версий](#8-системы-контроля-версий)
9.   [Важные для нас особенности языка Python](#9-важные-для-нас-особенности-языка-python)
10.  [Что может использоваться для программирования на Python](#10-что-может-использоваться-для-программирования-на-python)
11.  [Работа с Google colab в рамках модуля](#11-работа-с-google-colab-в-рамках-модуля)


## 1. Цели модуля
### 1.1. Основные цели модуля:
1. Познакомиться с концепциями компьютерной программы и процесса программирования
2. Познакомиться с базовыми понятиями программирования на примере языка Python
3. Получить навыки написания простых программ и составления алгоритмов.
4. Получить навыки использования существующих библиотек для решения задач обработки изображений

### 1.2. Почему был выбран Python?
#### 1.2.1. Язык программирования Python идеально подходит помимо прочего для задачи знакомства с программированием: 
- он обладает легко читаемым синтаксисом,
- обладает большим количеством готовых библиотек,
- отлично разобран в сети,
- может стать очень мощным инструментом решения задач даже в руках начинающего пользователя.
#### 1.2.2. Язык программирования Python используется как backend в большом количестве проектов:
- легче найти разработчиков,
- язык постоянно получает новые версии,
- язык способен решать серьезные наукоемкие задачи за счет доступных библиотек.

## 2. Формат модуля
### 2.1. Лекции
Всего 8 часов (4 пары).

- __Лекция 1.__  Информационные инструменты: существующие языки программирования, средства совместной разработки, облачные сервисы, инструменты планирования.
- __Лекция 2.__  Базовые понятия программирования: структура программ, библиотеки, переменные, типы данных, основные операции, работа с памятью компьютера.
- __Лекция 3.__  Базовые алгоритмические элементы программ: ветвление, циклы, простые структуры данных, объекты и доступ к ним.
- __Лекция 4.__  Отображение информации: растровая графика и работа с изображениями, графические библиотеки, работа с видео, хранение информации.

Лекционный материал будет доступен в репозитории и в moodle накануне занятия. Записи занятий будут доступны в комнате bbb или по прямой ссылке.

### 2.2. Практические работы
Всего 24 часа (6 практических занятий по 2 пары)

- __Практическое занятие 1.__ Создание информационной среды для совместной работы с использованием инструментов в открытом доступе.
- __Практическое занятие 2.__ Процесс написания программы, отладка программ, работа с ошибками.
- __Практическое занятие 3.__ Работа с данными различных типов, создание простых структур данных. Сложные арифметические выражения.
- __Практическое занятие 4.__ Разработка и реализация алгоритмов для решения задач различной сложности.
- __Практическое занятие 5.__ Обработка цифровых растровых изображений, использование графических библиотек.
- __Практическое занятие 6.__ Итоговое тестирование по модулю 2.

Задание для практической работы будет доступно после соответсвующей лекции. Все задания выполняются в одном файле - блокноте - "*.ipynb". Этот файл является результатом выполнения практического задания.

Предполагается, что вы за время занятия сможете выполнить все задания.

Домашняя самостоятельная работа подразумевает самостоятельное выполнение тех или иных заданий, выполнение части практического задания, изучение теоретических вопросов.

Присутствие на онлайн занятии с преподавателем дает вам возможность получить консультацию, ответ на вопрос, помощь с решением каких-либо проблем по модулю.

Кроме того можно использовать группу ТГ для того, чтобы задать вопрос и получить на него ответ не только от преподавателей, но и от ваших сокурсников.
Не стесняйтесь спрашивать: может быть ваш вопрос поможет кому-то еще.

В конце модуля из файлов-отчетов по каждой практической работе нужно будет собрать общий файл, который будет представлять из себя отчет по всему модулю.

__Мы вместе можем скорректировать тематику практических работ, если вы знаете, что вам пригодится.__

## 3. Компьютер как вычислитель
### 3.1. Эволюция компьютеров

Полезно ознакомиться в свободне время: [История вычислительной техники](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B8)

Вычислители в том виде, в котором мы с вами их знаем, эволюционировали из более примитивных (но не простых) устройств. Основная задача, которую решали предки современных компьютеров, была ускорить (или вообще осуществить) математические расчеты. 

В 1623 году Вильгельм Шиккард придумал «Считающие часы» — первый арифмометр, умевший выполнять четыре арифметических действия. Один из первых "процессоров". Принципы, заложенные в арифмометрах, используются и в современных процессорах. Классические процессоры (не оптические, не квантоввые) работают точно так же, но гораздо быстрее.

В 1804 году Жозеф Мари Жаккар разработал ткацкий станок, в котором вышиваемый узор определялся перфокартами. Первый способ записывать необходимые операции в формате, понятном для "исполнителя". Прототип запоминающих устройств.

В 1835 году Чарльз Бэббидж описал свою аналитическую машину.

В начале ХХ столетия появились первые механические клавишные арифмометры. Усовершенствование механических арифмометров продолжалось вплоть до 1970-х годов.

В 1936 году молодой немецкий инженер-энтузиаст Конрад Цузе начал работу над своим первым вычислителем серии Z, имевшим память (пока ограниченную) и возможность программирования.

Во время Второй мировой войны Великобритания достигла определённых успехов во взломе зашифрованных немецких переговоров. Код немецкой шифровальной машины «Энигма» был подвергнут анализу с помощью электромеханических машин, которые носили название «бомбы». Для взлома этого кода в обстановке секретности была создана машина «Колосс» (англ. Colossus). 

После ВМВ началась эра полностью электронных вычислителей.

__Вся современная электроника пошла от механических арифметических устройств и работает по тем же принципам__

### 3.2. Что вообще делает процессор

Электронный процессор выполняет те же операции что и механический арифмометр.

База: сложение двоичных чисел. Отричцательное число можно представить в особом виде через дополнительный код и тогда вычитание будет выполняться как сложение с дополнительным кодом.

При помощи сложения и смещения двоичной записи осуществляется умножение. Смещение тоже было реализовано в механическом арифмометре.

При помощи вычитания и смещения двоичной записи осуществляется деление чисел.

Это четыре основных операции над числами. Поэтому все что делает процессор - делает арифметические операции. Очень быстро, но ничего больше. К этому следует добавить возможность сохранять промежуточные значения, по адресу из памяти получать инструкции и значения чисел, над которыми нужно провести операции, соответствующие инструкциям.

Но как же все то многообразие задач, которое может решать современный компьютер? Здесь помогает математика. Именно она позволяет описать задачи так, чтобы свести их решение к простейшим арифметическим опреациям.
Также нужно понимать, что для работы компьютеру нужна информация в доступном для обработки виде, то есть в виде чисел.

__В основе всего лежит суммирование чисел__

### 3.3. Примеры вычислений в прикладных задачах: звук, видео, ИИ

Как мы слышим звук из колонок компьютера?
Звуковая волна записывается при помощи сенсоров (микрофон) и превращается в аналоговый электрический сигнал. Электрический сигнал оцифровывается, т.е. подбирается такой _очень_ близкий сигнал, который можно однозначно представить в виде конечного набора чисел (математика). Данные числа уже можно хранить в памяти компьютера, передавать, обрабатывать. Обратный процесс аналогичен. Числа превращаются в тот самый _очень_ близкий сигнал (математика), а он превращается в электрический (специальные устройства - ЦАП), который подается на колонки.

Как мы воспроизводится видео? Тот же самый процесс физический сигнал - сенсоры - аналоговый сигнал - оцифровка - обработка информации - генерация управляющего сигнала - воспроизведение.
Видеофайл это просто большой набор цифровых изображений, которые хранятся с той или иной степенью оптимизации. Вся обработка и воспроизведение строится на простейших арифметических операциях, которые выполняются или процессором или специальными электронными устройствам. Эти устройства на самом деле выполняют те же операции, но за счет электрических схем. Та же простая математика в основе.

Искуственный интеллект тоже описывается самым простейшими арифметическими функциями. Они собираются в математику посложнее. Подбираются правильные числа при обучении, эти числа хранятся и используются при обработке входящей информации для получения ответа. Во всех самых сложных задачах лежит математика. Причем, чаще всего, совершенно детерминированная. 

Основная идея заключается в том, что __компьютер делает (считает) только то, что ему написали считать__. Если это происходит не так, как вы ожидаете, то причина заключается в человеке. В ошибках программистов, в ошибках пользователей, во влиянии внешних _информационных_ факторов, которые может быть сложно учесть.

## 4. Ограничения компьютера

Основными ограничениями компьютеров является конечная точность расчетов, представления информации, скорость проведения расчетов. В цифровых компьютерах нет ничего бесконечного.

### 4.1. Примеры цифрового представления изображений

Изображение, как вы уже знаете можно представить в виде цифр. Часть реальной сцены превращается в пиксель, цветовые характеристики которого задаются числами. В зависимости от свойств этих чисел (доступной длины записи - битности) может меняться и точность воспроизведения изображений.

Картинка про разную глубину цвета

__В зависимости от наших потребностей и возможностей можно подобрать правильное цифровое представление чего угодно__

### 4.2. Примеры цифровой обработки изображений

Так как именно числа определяют цветовые характеристики цвета, то изменяя эти числа, можно менять цвет каждого конкретного пикселя. Оперируя математическими законами, определяющими изменения цвета, можно корректировать, изменять цифровые изображения. Так увеличение контраста конкретного изображения возможно при помощи применения соответствующей функции контрастирования, которая сводится опять же к простейшим арифметическим операциям.

Картинка про контрастирование.

Все операции над изображениями описываются математически. Если вы не занимаетесь разработкой таких операций, то вам даже не обязательно знать как они работают с точки зрения математики. Достаточно воспользоваться специальными интерфейсами соответствующих операций в графическом редакторе. Но "под капотом" будут проводиться те же арифметические вычисления.

__Любые сложные физические процессы можно описать через математику, в основе которой лежат просты операции__

### 4.3. Аналоговые сигналы как пример бесконечной точности

Мы не можем воссоздавать в цифре произвольный аналоговый сигнал, будь то звук, изображение, форма с бесконечной точностью. Ведь в компьютере нет ничего бесконечного. Но мы можем увеличивать точность и за счет этого приближаться к исходному аналоговому сигналу. Это требует дополнительных затрат памяти, времени на вычисления, да и воспроизводить такой сигнал может быть гораздо сложнее. Более того, в какой-то момент человек не сможет различать увеличение точности и тогда дальнейшее усложнение потеряет смысл.

Картинки с хабра про звук.

__Не обязательно воспроизводить все в точности, просто нужна правильная точность__

### 4.4. Реальный объект - аналоговое представление - модель объекта - математические зависимости - программа - вычисления компьютера

Получается, что все с чем может работать компьютер это числа. Но математика позволяет эти числа использовать для представления чего угодно. Переход от реальных объектов окружающего мира к простейшей математике, на которой работает процессор компьютера проходит по одинаковому "маршруту":

__Реальный объект или физическое явление__ -> _регистрация сенсорами его аналогового представления_ -> __аналоговый сигнал__ -> _оцифровка аналогового сигнала_ -> __цифровое представление__ -> _применение математических законов к числам представления_ ЗДЕСЬ ПОЯВЛЯЕТСЯ ПРОГРАММИРОВАНИЕ-> __цифровое представление__ -> _цифроаналоговое преобразование_ -> __аналоговый (управляющий) сигнал__ -> _воспроизведение специальными устройствами_ -> __реальный объект или физическое явление__ -> (восприятие человеком)

__Восприятие человеком это сложный процесс, который очень похож на цифровую обработку на компьютере, только происходит в аналоговом домене__

## 5. Программа

Мы подошли к понятиям которые определяют, как можно влиять на информацию и осуществлять ее преобразование.

### 5.1. Метод. Алгоритм. Программа

Три близких понятия, которые часто путают. Понятия даны в моем видении, не формальное определение.

Метод - строгое описание способов влияния на модель какого-либо объекта (или сам объект), с учетом законов поведения и особенностей представления модели или объекта.
Алгоритм - пошаговое (возможно упрощенное) описание действий по влиянию на модель для достижения желаемого результата.
Программа - описание алгоритма для того, кто/что будет осуществлять изменения модели.

Попробуйте привести пример того, как решение одной и той же задачи может быть описано как метод, алгоритм и программа.

### 5.2. Программа - формальное определение

Компьютерная программа — 1) комбинация компьютерных инструкций и данных, позволяющая аппаратному обеспечению вычислительной системы выполнять вычисления или функции управления; 2) синтаксическая единица, которая соответствует правилам определённого языка программирования, состоящая из определений и операторов или инструкций, необходимых для определённой функции, задачи или решения проблемы.

Человеческим языком:

_Программа_ - комбинация инструкций, написанных на языке программирования, понятном компилятору, и преобразуемая им в комбинацию инструкций, __понятных исполнителю__.

_Компилятор_ - специальная программа переводящая текст, написанный на языке программирования, в машинные коды.

Исполнителем в данном случае является процессор.

Пример для понимания: заказчик составляет техническое задание, которое способен понять инженер-конструктор; конструктор разрабатывает чертеж, понятный фрезеровщику; фрезеровщик на станке изготавливает деталь. В данном случае роль компилятора выполняет инженер-конструктор.

### 5.3. Когда исполнитель "не понимает"

[Когда папа-тестировщик учит детей программированию на примере бутербродов](https://www.reddit.com/r/Pikabu/comments/dxqxpg/%D0%BF%D0%B0%D0%BF%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82_%D0%B3%D0%BE%D1%80%D0%B5_%D0%B2_%D1%81%D0%B5%D0%BC%D1%8C%D0%B5/?rdt=56752)

Отличный пример того, что при использовании даже понятного для исполнителя языка без четких и полных правил можно интерпретировать иначе.

### 5.4. Языки программирования - формальное определение

Язык программирования — формальный язык, предназначенный для записи компьютерных программ. Язык программирования определяет набор лексических, синтаксических и семантических правил, определяющих внешний вид программы и действия, которые выполнит исполнитель (обычно — ЭВМ) под её управлением.

Формальный язык в математической логике, информатике и лингвистике — множество конечных слов (строк, цепочек) над конечным алфавитом. Понятие языка чаще всего используется в теории автоматов, теории вычислимости и теории алгоритмов. И вот тут снова появляется математика, это к тому, почему программирование дается проще тем, у кого хорошо с математикой (но это не точно).

Каждое слово в программе должно нести совершенно конкретную информацию и пониматься единственным способом. Этим естественные языки отличются от формальных.

## 6. Примеры известных языков программирования

Легкое чтение перед сном (с) Гермиона Гренджер

[Про популярные языки](https://elbrusboot.camp/blog/rieitingh-iazykov-proghrammirovaniia-2023/)

Популярные не значит лучшие, обычно это означает экономически эффективные.

### 6.1. С++ как современный эталон

__C++__ разработан как расширение языка С. Он предоставляет возможности для низкоуровневого программирования и позволяет эффективно работать с аппаратным обеспечением. В основном он применяется в разработке игр, систем реального времени, встраиваемого ПО, высокопроизводительных приложений.

Преимущества С++:
- близок к аппаратному обеспечению
- может легко манипулировать ресурсами
- поддерживает процедурное программирование для функций, интенсивно использующих ЦП
- является очень быстрым

### 6.2. Python самый комфортный язык

__Python__ — это высокоуровневый язык программирования, с помощью которого создают сайты, разрабатывают приложения, автоматизируют процессы анализа или визуализации данных. Python не был разработан для конкретных целей, поэтому подходит как для создания алгоритма рекомендаций видеосервиса, так и для разработки программного обеспечения для самоуправляемых автомобилей или управления космическими аппаратами на других планетах.

__Лёгкость освоения.__ Python прост, логичен, имеет понятный синтаксис, поэтому подходит даже для новичков. Для его изучения не нужны знания английского.

__Простота визуального воспитания.__ Блоки кода отделяются отступами, за счёт меньшего объёма код также воспринимается проще.

__Кроссплатформенность.__ Программы, написанные на Python, могут запускаться и функционировать на всех типах операционных систем. Отличия можно узнать заранее, поскольку они подробно описаны в документации.

__Скорость разработки.__ Чтобы написать программу на Python нужно значительно меньше кода, чем при разработке, например — на Java.

__Универсальность.__ Благодаря интерпретируемости пайтона он используется практически на всех платформах для различных задач — от тестирования до научных исследований. Код удобно писать даже в стандартных текстовых редакторах.

__Множество инструментов.__ Стандартные библиотеки Python способны решать даже сложные задачи. Установка дополнительных модулей, созданных для конкретных целей, помогает при разработке специальных проектов.

__Масштабируемость.__ Возможность адаптации высокоуровневой логики позволяет проектам, разработанным на Python, масштабироваться и расширяться.

### 6.3. Java первое воплощение кроссплатформенности

__Java__ – универсальный объектно-ориентированный язык со строгой типизацией. В нём реализован принцип WORA (от английского: write once, run anywhere). Это позволяет запускать приложения везде, где есть среда исполнения JRE (от английского: Java Runtime Environment). Механизм работы программ следующий. Исходный материал транслируется в байт-код, который обрабатывается виртуальной машиной Java (JVM). При этом не имеет значения, какая операционная система установлена на устройстве.

__Простота__ – первое техническое достоинство Java. У него чёткие синтаксические правила и понятная семантика. Рациональность и краткость очень полезны для обработки кода машинами с ограниченным объёмом ресурсов. Для встроенных устройств создана специальная платформа Java Micro Edition.

__Объектно-ориентированный подход.__ За 3 десятилетия он доказал свою эффективность. Суть состоит в том, что в центре внимания находятся данные (объекты), интерфейсы и алгоритмы вторичны. Другими словами, мы отталкиваемся от результата при выборе инструментов, способов их применения.

__Безопасность.__ Важнейший критерий, учитывая применение языка в сетевых / распределенных средах. Разработчики проделали большую работу по защите платформы Java. И она продолжается. Обойти или взломать механизмы защиты крайне сложно. Пример: использование классов, имеющих цифровую подпись. Полные права предоставляются только при полном доверии автору класса.

__Производительность.__ Изначально она вызывала вопросы. Новые версии динамических компиляторов Java не уступают традиционным из других платформ. Мощный прирост скорости обработки даёт оптимизация тех фрагментов кода, которая исполняется чаще. При необходимости те или иные приёмы оптимизации включаются или отменяются JIT-компилятором.

__Надёжность__ – одно из важнейших преимуществ. Программы на Java стабильно работают в любых условиях. Компилятор способен выявить ошибки ещё до выполнения кода, то есть на ранних стадиях. Контроль выполнения позволяет предотвратить сбои в памяти (например, из-за неточного указателя). Сами указатели можно применять не везде, а только там, где это необходимо (скажем, в работе со связными списками).

__Независимость от аппаратной части и ОС.__ Важно лишь наличие исполняющей среды и JVM. А компьютерная архитектура в целом значения не имеет. Байт-код легко интерпретируется на любой машине. Подход доказал свою состоятельность во многом благодаря динамической компиляции. Кроссплатформенностью отличается также интерфейс, реализованный в системных библиотеках.

__Динамичность и адаптируемость.__ Эта особенность позволяет Java не теряться в постоянно изменяющейся среде. При необходимости можно добавить в библиотеки новые объекты, методы. При этом трогать приложения, использующие данные библиотеки не нужно. Отследить информацию о структуре объектов, их поведении, о ходе выполнения программы очень легко.

__Удобные и эффективные сетевые возможности.__ Приложения умеют находить нужные объекты в сети и открывать к ним доступ. Причём так же легко, как будто мы имеем дело с локальной файловой системой. Имеется обширная программная библиотека для передачи данных по самым распространённым протоколам: FTP, HTTP, TCP/IP. Работает механизм вызова удалённых методов.

Главным преимуществом, которое определило выбор языка для практической части этого курса, стало легкость освоения. Поэтому мы и будем работать на Python. Он самый приятный для знакомства, хоть и с него потом трудно переходить на другие языки.

## 7. Процесс программирования

### 7.1. Программы пишутся на формальных языках

Как писать программы? Нужно знать приавила конкретного языка, зарезервированные слова, особенности применения. В Python это достаточно легко запоминается, поэтому нужно чаще практиковаться, чаще совершать ошибки, выяснять в чем дело и исправлять их. В отличие от многих других предметов, даже неправильное решение приводит к обучению - вы учитесь, запоминаете.

Как правило большинство современных языков использует в своей базе английский язык. Поэтому, если вы легко освоили иностранный язык (любой), вам будет проще разобраться с программированием.

Программа, которую вы пишите, по сути обычный текст, написанный в текстовом редакторе. Если вы используете специальную среду разработки, то вокруг текстового редактора будет выстроено огромное количество дополнительных улучшений, нацеленных на повышение вашей информированности в процессе работы над текстом программы. Различные подсказки, способы сруктурировать ваши результаты и т.д. 

Среда разработки включает в себя:
- текстовый редактор,
- транслятор (компилятор и/или интерпретатор),
- средства автоматизации сборки,
- отладчик (дебаггер, от англ. - debugger ).
  
Иногда содержит также средства для интеграции с системами управления версиями и разнообразные инструменты для упрощения конструирования графического интерфейса пользователя. 

### 7.2. Компиляция программы - перевод в машинные коды

После того, как написан текст программы, его пропускают через компилятор, которая пытается перевести текст в машинные коды. Если вы не ошибличь с точки зрения языка текста, то у вас появится уже исполняемый код. Если вы при этом не ошибличь в реализации алгоритма, то исполняемый код будет делать то, что вы запланировали.

После запуска исполняемого файла процессор начинает выполнять команды, обрабатывать информацию как числа.

### 7.3. Ошибки и их исправление: сообщения об ошибках, получение неверных результатов

Но что, если программа не работает или работает не так как нужно? Значит где-то была совершена ошибка. Существует несколько типов ошибок.

**1. Логические ошибки**
Наиболее серьезная из всех ошибок. Когда написанная программа на любом языке компилирует и работает правильно, но выдает неправильный вывод, недостаток заключается в логике основного программирования. Это ошибка, которая была унаследована от недостатка в базовом алгоритме. Сама логика, на которой базируется вся программа, является ущербной. Чтобы найти решение такой ошибки нужно фундаментальное изменение алгоритма. Вам нужно начать копать в алгоритмическом уровне, чтобы сузить область поиска такой ошибки.
_Пример ошибки_: ваш алгоритм складывая 15 яблок и 16 яблок получает 1,434,123.312 апельсинов.

**2. Синтаксические ошибки**
Каждый компьютерный язык, такой как C, Java, Perl и Python имеет специфический синтаксис, в котором будет написан код. Когда программист не придерживаться "грамматики" спецификациями компьютерного языка, возникнет ошибка синтаксиса. Такого рода ошибки легко устраняются на этапе компиляции. Зачастую среда программирования найдет эти ошибки за вас, укажет на них или сама же исправит. Суть таких ошибок заключается в нарушении правил написания комбинаций символов для конкретного языка.

**3. Ошибка компиляции**
Компиляция это процесс, в котором программа, написанная на языке высокого уровня, преобразуется в машиночитаемую форму. Многие виды ошибок могут происходить на этом этапе, в том числе и синтаксические ошибки. Иногда, синтаксис исходного кода может быть безупречным, но ошибка компиляции все же может произойти. Это может быть связано с проблемами в самом компиляторе. Эти ошибки исправляются на стадии разработки.

**4. Ошибки среды выполнения (RunTime)**
Программный код успешно скомпилирован, и исполняемый файл был создан. Вы можете вздохнуть с облегчением и запустить программу, чтобы проверить ее работу. Ошибки при выполнении программы могут возникнуть в результате аварии или нехватки ресурсов носителя. Разработчик должен был предвидеть реальные условия развертывания программы. Это можно исправить, вернувшись к стадии кодирования.

**5. Арифметическая ошибка**
Многие программы используют числовые переменные, и алгоритм может включать несколько математических вычислений. Арифметические ошибки возникают, когда компьютер не может справиться с проблемами, такими как "Деление на ноль", или ведущие к бесконечному результату. Это снова логическая ошибка, которая может быть исправлена только путем изменения алгоритм

**6. Ошибки ресурса**
Ошибка ресурса возникает, когда значение переменной переполняет максимально допустимое значение. Переполнение буфера, использование неинициализированной переменной, нарушение прав доступа и переполнение стека - примеры некоторых распространенных ошибок.

**7. Ошибка взаимодействия**
Они могут возникнуть в связи с несоответствием программного обеспечения с аппаратным интерфейсом или интерфейсом прикладного программирования. В случае веб-приложений, ошибка интерфейса может быть результатом неправильного использования веб-протокола.

### 7.4. Отладка программ: исправление ошибок, трэкинг работы, текстовые сообщения, тесты

Проще всего обнаружить и исправить синтаксические ошибки. Вам об этом даст знать компилятор в сообщении об ошибке. Как правило он укажет и номер строки и типа ошибки. Вам нужно будет только исправить написание.

С логическими ошибками сложнее: вам придется изучать, как реализована логика решения задачи. То есть проверять каждый шаг работы программы.

Есть несколько подходов:
- использовать пошаговую отладку и на каждом шаге изучать значения переменных,
- добавить в текст программы возможность выводить сообщения с интересующими вас цифрами, начать вести логи,
- использовать набор зарание продуманных входных данных, результат обработки которых вам заранее известен, тестирование.

**На этапе знакомства с программированием чаще всего будут встречаться первые два типа ошибок: синтаксические и логические.**
С первыми нам поможет компилятор. Вторые мы будем пытаться отлавливать при помощи пошаговой отладки. В этом нам очень сильно поможет то, что Python компилируемый интерпретируемый язык

Существуют языки программирования, в которых есть стадия компиляции в машинный код.

Python работает по-другому. Программа исполняется интерпретатором шаг за шагом, а не запускается напрямую на процессоре компьютера. Поэтому для запуска программы на Python всегда нужна среда исполнения (интерпретатор). Только она может выполнять Python-программы.

Строго говоря, и у Python есть фаза компиляции, но при этом внешне он ведет себя именно как интерпретируемый язык программирования:
- Вы запускаете программу.
- Интерпретатор открывает файлы программы и загружает из них исходный код.
- Затем интерпретатор преобразует исходный код в байткод, проверяет ошибки синтаксиса и начинает исполнять **по шагам**.

__Python компилируется как обычный язык, а потом специальная программа (привет кроссплатформенности) - интерпретатор разбирает машинныйкод на куски и выполняет его по шагам, соответствующим шагам исходной программы__

## 8. Системы контроля версий
### 8.1. Современное программирование - работа многих людей над одним результатом
Редкие проекты пишут в одиночку. Редкие проекты состоят из одного куска. Сложно отлаживать весь проект целиком.

Над созданием ПО трудятся сразу много людей. ПО разбито на модули и собирается в единое целое на последнем этапе. Каждый модуль можно писать независеимо от остальных, когда способ связи между модулями определен.
появляются проблемы синхронизации работы. 

Одна часть команды написала свой модуль быстро, а у второй появились ошибки. Нужно ли ждать первой команде вторую?

Кто-то написал новую часть программы и у остальных все поломалось. Как вернуть то, что работало?

Кто-то внес изменения и теперь непонятно, а что из тысяч строк кода изменилось?

Два человека одновременно параллельно работали над решением одной задачи. Сначала один сохранил свое изменение, затем второй переписал поверх свое решение. Первое решение затерлось полностью. Как быть и где искать? [Хорошая илюстрация этой проблемы.](https://habr.com/ru/articles/552872/)

### 8.3. Системы контроля версий

Система контроля версий — это система, записывающая изменения в файл или набор файлов в течение времени и позволяющая вернуться позже к определённой версии. Если вы захотите потом работать в большом проекте с другими людьми, настоятельно рекомендую познакомиться с этими системами. Они позволяют экономить кучу времени и нервов.

Самой популярной системой контроля версий можно смело назвать Git и онлайн-хранилища под управлением разных компаний ([GitHub](https://github.com/) и [GitLab](https://about.gitlab.com/)). Эти онлайн хранилища позволяют бесплатно создавать хранилища кода для проектов и делиться им (или не делиться, но уже за деньги). Такое хранилище можно создать и самостоятельно для своих проектов, без привязки внешних сервисов.

### 8.4. Распространение результатов при помощи систем контроля версий

Системы контроля версий можно использовать не только для программирования. Вы можете синхронизировать любые файлы у нескольких людей, где каждый сможет работать параллельно с остальными. Более того, я использую GitHub для распространения своих файлов. И эта лекция не исключение. Все файлы открыты и доступны для копирования или использования в своих целях. Однако, если вы планируете использовать результаты чужого труда, следует выяснить на каких условиях эти результаты передавались.

### 8.5. Markdown документы. Markdown в системах контроля версий

Оформление текста и получение похожих документов стало возможно за счет применения языка разметки Markdown, файлы имеют разрешение "*.md". Вам может сильно пригодиться умение работать с такими документами: они позволяют получить полноценный документ с картинками и сложными формулами без применения сложных и/или дорогих редакторов прямо в Git-системах, сейчас мы находимся в GitHub. Нужно это в первую очередь для легкого создания описаний проектов и разъяснений к ним, которые часто требуют иллюстраций и математических формул.

Есть множество справочников по MarkDown, советую использовать [шпаргалку](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c)

### 8.6. Примеры лекций в блокнотах

На моем репозитории можно найти несколько вариантов лекций по разным курсам. Эти лекции выполнены в MD-формате.
[Лекция по общей информатике](https://github.com/bbkvsrg/lecture-notes/blob/main/%D0%9E%D0%98/lecture_01.md)
[Лекция про зрительную систему человека](https://github.com/bbkvsrg/lecture-notes/blob/main/%D0%A6%D0%9E%D0%98/lectures/lecture_01/lecture_01.md)

## 9. Важные для нас особенности языка Python

А теперь об особенностях Python, которые мы будем непосредственно использовать.
- Пошаговая интерпретация поможет нам постепенно выполнять инструкции, отслеживать изменения значений, прослеживать и отлаживать логику программы при обучении программированию.
- Мы будем использовать блокноты (notebooks) и специальные средства для работы с ними. Блокноты позволяют разделять на части код программы и выполнять части пошагово. Ктоме того между частями кода есть возможность вставлять текст с комментариями в формате MarkDown, что позволяет использовать блокнот одновременно как:
  + файл с заданием на практическую работу,
  + файл с вашей программой, которую вы допишете,
  + файл с отчетом и иллюстрациями о выполнении работы.
 
Файлы с лекциями и с заданиями будут доступны и в репозитории и продублированы в систему Moodle.

## 10. Что может использоваться для программирования на Python
[Полезный список того, на чем можно писать на Python вообще](https://blog.skillfactory.ru/vybiraem-ide-programmy-dlya-kodinga-na-python/)

Писать программы для Python можно разными способами. Самый сложный и нацеленный на профессиональную разработку способ - использование среды разработки.

Для учебных целей можно использовать онлайн компиляторы, которые позволяют писать программы и запускать их онлайн, прямо в браузере. [Например](https://pythononlinecompiler.ru/)

Писать программу хоть с какими-то удобствами (хотя бы выделение ключевых слов) можно даже в блокноте. Специализированном блокноте **Notepad++**, например.
### 10.1. Существующие среды разроботки на Python

Мы не будем ставить громоздкую среду разработки на ваши компьютеры, но вы всегда можете поискать что-то из...
- [PyChrm](https://www.jetbrains.com/ru-ru/pycharm/) - субъективно лучшая среда для профессиональной разработки
- [Spyder](https://www.spyder-ide.org/) - полегче попроще
- [Thonny](https://thonny.org/) - максимально простая среда

  Не все может быть доступно, санкции...

### 10.2. Надстройка Jupyter Lab

Для облегчения работы с блокнотами есть такая замечательная надстройка [Jupyter Lab](https://jupyter.org/), она позволяет иметь на компьютере только браузер и интерпретатор Python. Запуск этой надстройки в вашем же браузере открывает интерфейс для работы с блокнотами. Очень лаконично по установке и очень мощно по результату. Но помните, вычисления выполняются на вашем процессоре, который может оказаться не достаточно силен для сложных задач.

### 10.3. Google colab для работы с блокнотами

А вот было бы вообще прекрасно блокноты запускать где-нибудь в облаке на мощных процессорах, без необходимости нагружать свой компьютер. [Google colab](https://colab.research.google.com/)

Полный функционал блокнотов Jupyther, без ограничений на вашу систему. Главное, чтобы был интернет.

Вот этим сервисом мы и воспользуемся для того, чтобы все были в равных условиях. Но при желании вы все можете запускать там, где вам удобнее или привычнее.

## 11. Работа с Google colab в рамках модуля

В рамках модуля все практические задания будут даваться в предположении, что вы будете их выполнять с использованием бесплатного сетевого облачного сервиса [Google colab](https://colab.research.google.com/).

В чем особенности и преимущество данного сервиса для нашего модуля?

### 11.1. Подключение google disk

Вы можете запускать файлы-блокноты, которые хранятся у вас на Google Disk, можете к ним даже совместный доступ организовать (образуя временные команды), можете подгружать файлы со своего компьютера.

Вы можете работать с использованием любого браузера и любого устройства в вашем распоряжении. Вычислительные способности которые предлагает эта платформа весьма впечатляют.

Максимальная независимость от обстоятельств.

### 11.2. Долгие вычисления в colab

Есть особенность, про которую стоит упомянуть. У нас таких заданий не будет, но для общей эрудиции. Если у вас какие-то вычисления на этой платформе выполняются дольше чем 2 часа без обмена сообщениями между исполняемым кодом и вашим браузером (без вывода текста, например), система управления может посчитать, что программа зависла и отключить ее. Пожэтому коллеги пользовались небольшим лайфхаком - предусмотрели периодический вывод текста на экран пользователя во время вычислений. Таким образом обучались нейронные сети с использованием ресурсов.

### 11.3. Абсолютная и относительная адресация. Точка запуска программы, текущая папка

В Google colab запускается небольшая виртуальная машина, где-то там на серверах облака. А вам предоставляют доступ к ней через браузер. В очень усеченном формате. Поэтому точкой запуска программы является виртуальное место на неизвестном сервере в удаленном облаке. Это приводит к тому, что адреса файлов которые вы захотите использовать в своей программе будут только относительными. Вы будете видет некий каталог, который и будет содержать все ваши файлы. Абсолютная адресация здесь не сработает.

__Для работы в рамках модуля вам потребуется акаунт Google.__ А все остальное мы попробуем на практическом занятии.




